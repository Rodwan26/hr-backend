from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from typing import List, Optional, Any, Dict

from app.database import get_db
from app.models.employee import Employee
from app.models.wellbeing_assessment import WellbeingAssessment
from app.services.wellbeing_service import WellbeingService
from app.services.ai_trust_service import AITrustService
from app.schemas.trust import TrustedAIResponse
from app.models.user import UserRole, User
from app.routers.auth_deps import require_role, get_current_user, get_current_org
from app.core.limiter import limiter
from pydantic import BaseModel

router = APIRouter(
    prefix="/wellbeing", 
    tags=["wellbeing"],
    dependencies=[Depends(require_role([UserRole.HR_ADMIN, UserRole.HR_STAFF]))]
)

# Schemas for data payload
class WellbeingData(BaseModel):
    support_priority: str
    details: str
    recommendations: List[str]

class FrictionData(BaseModel):
    has_friction: bool
    explanation: str
    support_hint: str

class FrictionCheckRequest(BaseModel):
    text: str

def check_dept_access(user: User, employee_id: int, db: Session, org_id: int):
    if user.role == UserRole.HR_ADMIN:
        # Still need to ensure the employee belongs to the same org even for HR_ADMIN
        employee = db.query(Employee).filter(
            Employee.id == employee_id,
            Employee.organization_id == org_id
        ).first()
        if not employee:
            raise HTTPException(status_code=404, detail="Employee not found")
        return
        
    employee = db.query(Employee).filter(
        Employee.id == employee_id,
        Employee.organization_id == org_id
    ).first()
    if not employee:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    # Department check (if applicable)
    if hasattr(user, 'department') and user.department != employee.department:
        raise HTTPException(
            status_code=403,
            detail=f"Access denied: You can only access employees in {user.department}"
        )

@router.post("/analyze/{employee_id}", response_model=TrustedAIResponse)
@limiter.limit("10/minute")
def assess_employee_wellbeing(
    request: Request,
    employee_id: int, 
    db: Session = Depends(get_db), 
    current_user: User = Depends(get_current_user),
    org_id: int = Depends(get_current_org)
):
    """
    Assess an employee's wellbeing support needs based on workspace signals.
    Returns TrustedAIResponse.
    """
    check_dept_access(current_user, employee_id, db, org_id)

    try:
        service = WellbeingService(db, organization_id=org_id)
        result = service.calculate_risk(employee_id)
        
        # Prepare structured data
        data_payload = {
            "support_priority": result["support_priority"],
            "details": result.get("analysis", result.get("details", "")),
            "recommendations": result["recommendations"]
        }
        
        # Save to database (Legacy/Persistence)
        # Trust metadata is generated by wrapper, but we might want to store it in DB too.
        # However, wrap_and_log generates it. We can either generate it before or extract it.
        # AITrustService.wrap_and_log returns the response object with trust metadata.
        
        trust_service = AITrustService(
            db, 
            organization_id=org_id, 
            user_id=current_user.id, 
            user_role=current_user.role
        )
        
        # We wrap the response. The service handles logging.
        response = trust_service.wrap_and_log(
            content=data_payload["details"], # Main text content
            data=data_payload,              # Structured data
            action_type="wellbeing_assessment",
            entity_type="wellbeing_assessment",
            entity_id=None, # We don't have ID yet if we create it after, or we create it now.
            # Ideally we save assessment first then log.
            # Let's save assessment first without trust metadata, then update it? 
            # Or just pass entity_id=None and rely on log Details.
            confidence_score=0.85, # Placeholder, in real app comes from service.calculate_risk
            model_name="HR-Wellbeing-v1",
            reasoning="Based on workload and communication patterns."
        )
        
        # Now save to DB including the generated trust metadata
        db_assessment = WellbeingAssessment(
            employee_id=employee_id,
            support_priority=result["support_priority"],
            wellbeing_analysis=result.get("analysis", ""),
            support_recommendations=result.get("recommendations", []),
            trust_metadata=response.trust.model_dump(),
            organization_id=org_id
        )
        db.add(db_assessment)
        db.commit()
        
        # We could update the log with the entity_id if we wanted perfect linking, 
        # but the log already happened.
        # This is a trade-off. For now, we trust the log details.
        
        return response

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Wellbeing service error: {str(e)}")

@router.post("/check-friction", response_model=TrustedAIResponse)
@limiter.limit("20/minute")
def check_friction_indicators(
    request: Request, 
    friction_req: FrictionCheckRequest,
    db: Session = Depends(get_db), # Need DB for trust service
    current_user: User = Depends(get_current_user),
    org_id: int = Depends(get_current_org)
):
    """
    Analyze text for workplace friction. Returns TrustedAIResponse.
    """
    try:
        service = WellbeingService(db, organization_id=org_id)
        result = service.check_friction(friction_req.text)
        # result is dict: {has_friction, explanation, support_hint, trust_metadata}
        
        trust_service = AITrustService(
            db, 
            organization_id=org_id, 
            user_id=current_user.id, 
            user_role=current_user.role
        )
        
        data_payload = {
            "has_friction": result["has_friction"],
            "explanation": result["explanation"],
            "support_hint": result["support_hint"]
        }
        
        return trust_service.wrap_and_log(
            content=result["explanation"],
            data=data_payload,
            action_type="check_friction",
            entity_type="text_analysis",
            confidence_score=0.9,
            model_name="HR-Sentiment-v1",
            reasoning="Sentiment analysis of provided text."
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Friction analysis error: {str(e)}")

@router.get("/assessments/{employee_id}", response_model=List[WellbeingData])
def get_wellbeing_history(
    employee_id: int, 
    db: Session = Depends(get_db),
    org_id: int = Depends(get_current_org)
):
    """
    Retrieve history. 
    Note: History endpoints usually return simple lists, not wrapped in TrustedAIResponse for the list itself,
    but the items could contain trust metadata if needed. 
    Here we keep it simple as per original, but returning WellbeingData schema.
    """
    assessments = db.query(WellbeingAssessment).filter(
        WellbeingAssessment.employee_id == employee_id,
        WellbeingAssessment.organization_id == org_id
    ).order_by(WellbeingAssessment.assessed_at.desc()).all()
    
    return [
        {
            "support_priority": a.support_priority,
            "details": a.wellbeing_analysis,
            "recommendations": a.support_recommendations
            # trust_metadata stored in DB is not returned in this simplified view, 
            # but could be added if frontend needs validtion history.
        } for a in assessments
    ]
@router.get("/tip", response_model=TrustedAIResponse)
def get_organizational_wellbeing_tip(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    org_id: int = Depends(get_current_org)
):
    """
    Generate a pro-active wellbeing tip based on organizational sentiment and risk patterns.
    """
    try:
        service = WellbeingService(db, organization_id=org_id)
        result = service.get_org_wellbeing_tip()
        
        trust_service = AITrustService(
            db, 
            organization_id=org_id, 
            user_id=current_user.id, 
            user_role=current_user.role
        )
        
        return trust_service.wrap_and_log(
            content=result["tip"],
            data={"priority": result.get("priority", "medium")},
            action_type="generate_wellbeing_tip",
            entity_type="organization",
            confidence_score=0.95,
            model_name="HR-Strategy-v1",
            reasoning="Derived from aggregated organizational telemetry patterns."
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Tip generation failed: {str(e)}")
